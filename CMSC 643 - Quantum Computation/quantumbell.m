(* ::Package:: *)

(* ::Input:: *)
(*(*---------------------------------------------------------------------------------*)*)
(*(*---------------- Sandipan Dey, UMBC CSEE ----------------------------------------*)*)
(*(*---------------- The Source Code for Quantum Bell Package -----------------------*)*)
(*(*---------------- Major Functions --------------------------------------------------*)
(*				1. ComputeBellBasis*)
(*			    2. ComputeEPRPairs*)
(*                3. ComputeBellProjectors *)
(*                4. ComputeBellProbStates *)
(*			    5. ShowEntangledOutputTables*)
(*------------------------------------------------------------------------------------*)*)
(**)
(*BeginPackage["QuantumBell`"]*)
(**)
(*Begin["`Private`"]*)
(**)
(*Bra[k_, b_] := {b[[k + 1]]};*)
(*Ket[k_, b_] := Bra[k, b]\[ConjugateTranspose];*)
(*BraVec[coeff_, b_] := KetVec[coeff, b]\[ConjugateTranspose];*)
(*KetVec[coeff_, b_] := Module[{n, v, i, j},*)
(*	n = Dimensions[b][[1]]; v = Table[0, {i, n}, {j,1}]; Do [v = v + coeff[[i]] * Ket[i - 1, b], {i,n}]; v*)
(*];*)
(*InnerProduct[\[CapitalPsi]1_, \[CapitalPsi]2_] := \[CapitalPsi]1\[ConjugateTranspose].\[CapitalPsi]2;*)
(*InnerProductReal[\[CapitalPsi]1_, \[CapitalPsi]2_] := \[CapitalPsi]1\[Transpose].\[CapitalPsi]2;*)
(*TensorProduct[\[CapitalPsi]1_, \[CapitalPsi]2_] := KroneckerProduct[\[CapitalPsi]1,\[CapitalPsi]2];*)
(*TensorProduct[\[CapitalPsi]1_, \[CapitalPsi]2_, \[CapitalPsi]3_] := KroneckerProduct[KroneckerProduct[\[CapitalPsi]1,\[CapitalPsi]2],\[CapitalPsi]3];*)
(*Basis[n_] := IdentityMatrix[n];*)
(**)
(*(* Computes the Bell Basis *)*)
(*ComputeBellBasis[] := Module[{b, p00, p01, p10, p11, b1, b2, b3, b4},*)
(*                    b = Basis[2];*)
(*	          p00 = TensorProduct[Ket[0, b], Ket[0,b]] ;*)
(*		 p11 = TensorProduct[Ket[1, b], Ket[1,b]] ;*)
(*	          p01 = TensorProduct[Ket[0, b], Ket[1,b]] ;*)
(*		 p10 = TensorProduct[Ket[1, b], Ket[0,b]] ;*)
(*	          b1 = (p00 + p11) / Sqrt[2];*)
(*		 b2 = (p01 + p10) / Sqrt[2];*)
(*		 b3 = (p01 - p10) / Sqrt[2];*)
(*		 b4 = (p00 - p11) / Sqrt[2];*)
(*		 {b1\[Transpose], b2\[Transpose], b3\[Transpose], b4\[Transpose]}*)
(*];*)
(**)
(*(* Computes EPR Pairs *)*)
(*ComputeEPRPairs[] := Module[{b}, *)
(*b = Basis[2];(TensorProduct[Ket[0, b], Ket[1,b]]-TensorProduct[Ket[1,b], Ket[0, b]])/Sqrt[2]];*)
(*(* Computes GHZ Pairs *)*)
(*ComputeGHZPairs[] :=  Module[{b}, *)
(*b = Basis[2];(TensorProduct[Ket[0, b], Ket[0, b], Ket[0, b]]+TensorProduct[Ket[1, b], Ket[1, b], Ket[1, b]])/Sqrt[2]];*)
(*(* Computes Werner Pairs *)*)
(*ComputeWernerPairs[] :=   Module[{b},*)
(* b = Basis[2];*)
(*(TensorProduct[Ket[0, b], Ket[0, b], Ket[1, b]]+TensorProduct[Ket[0,b], Ket[1, b], Ket[0, b]]+TensorProduct[Ket[1, b], Ket[0,b], Ket[0, b]])/  Sqrt[3]];*)
(**)
(*(* Computes EPR Pairs (0,1) and (2,3) entangled*)*)
(*ComputeEPRPairs0123Entangled[] := Module[{BIT01,BIT23,BIT0123},*)
(*         BIT01 = BIT23 = ComputeEPRPairs[];*)
(*         BIT0123 = TensorProduct[BIT01,BIT23];(* (0, 1), (2, 3) Entangled *)*)
(*         {BIT01,BIT23,BIT0123}*)
(*];*)
(**)
(*(* Computes GHZ Pairs (0,1,2) and (3,4,5) entangled*)*)
(*ComputeGHZPairs012345Entangled[] := Module[{BIT012,BIT345,BIT012345},*)
(*         BIT012 =  BIT345 =ComputeGHZPairs[];  *)
(*         BIT012345 = TensorProduct[BIT012,BIT345];(* (0, 1, 2), (3, 4, 5) Entangled *)*)
(*        {BIT012,BIT345,BIT012345}*)
(*];*)
(**)
(*(* Computes Werner Pair (0,1,2) and GHZ Pair (3,4,5) entangled*)*)
(*ComputeWernerGHZPairs012345Entangled[] := Module[{BIT012,BIT345,BIT012345},*)
(*         BIT012 =ComputeWernerPairs[];  *)
(*         BIT345 = ComputeGHZPairs[];*)
(*         BIT012345 = TensorProduct[BIT012,BIT345]; (* (0, 1, 2), (3, 4, 5) Entangled *)*)
(*        {BIT012,BIT345,BIT012345}*)
(*];*)
(**)
(*(* Computes Werner Pair (0,1,2) and EPR Pair (3,4) entangled*)*)
(*ComputeWernerEPRPairs01234Entangled[] := Module[{BIT012,BIT34,BIT01234},*)
(*         BIT012 =ComputeWernerPairs[];  *)
(*         BIT34 = ComputeEPRPairs[];*)
(*         BIT01234 = TensorProduct[BIT012,BIT34]; (* (0, 1, 2), (3, 4) Entangled *)*)
(*        {BIT012,BIT34,BIT01234}*)
(*];*)
(**)
(*(* ComputeBellProjectors: Computes the Projectors *)*)
(*(* Inputs \[Implies] V: Bell Basis containing orthonormal eignevectors, n: Dimension of the EigenSpace *)*)
(*(* Output \[Implies] n Projectors *)*)
(*ComputeBellProjectors[V_,n_] := Module[{P, pVerify, oVerify, i, j, ZeroMatrix, ket, braw},*)
(*       pVerify = oVerify = True;*)
(*       P = Table[0, {i,  n}, {j, 1}];*)
(*       Do[ket=V[[i]]\[Transpose];braw=ket\[ConjugateTranspose];P[[i]]=ket.braw,{i,n}];*)
(*       ZeroMatrix= Table[0, {i, n}, {j,n}];*)
(*       Do[Do[If[P[[i]].P[[j]]!=ZeroMatrix   and i !=   j,oVerify = False,],{i,n}],{j,n}]; (*Verify Kronecker*)*)
(*      {P, pVerify}*)
(*];*)
(**)
(*(* ComputeBellProbStates: Computes the Probabilities and the States *)*)
(*(* Inputs \[Implies] P: n Projectors, \[CapitalPsi]: Quantum System, n: Dimension of the EigenSpace *)*)
(*(* Output \[Implies] n Probabilities and the States *)*)
(*ComputeBellProbStates[P_,\[CapitalPsi]_,n_, I1_,I2_] := Module[{prob, state, Proj, i},*)
(*        Proj =Table[TensorProduct[I1, P[[i]], I2],{i,n}];*)
(*        prob=Table[Expand[\[CapitalPsi]\[ConjugateTranspose].Proj[[i]].\[CapitalPsi]][[1]][[1]],{i,n}]; (*Probabilities*)*)
(*        state=Table[Map[Simplify,Transpose[{Normalize[ Transpose[Proj[[i]].\[CapitalPsi] ][[1]]]}]],{i,n}]; (*States*)*)
(*        {prob, state}*)
(*];*)
(**)
(*(* ComputeBellProbStatesWithUnitaryTransform: Computes the Probabilities and the States after Unitary Transformation *)*)
(*(* Inputs \[Implies] P: n Projectors, \[CapitalPsi]: Quantum System, n: Dimension of the EigenSpace, U: the Unitary Matrix *)*)
(*(* Output \[Implies] n Probabilities and the States *)*)
(*ComputeBellProbStatesWithUnitaryTransform[P_,\[CapitalPsi]_,n_, I1_,I2_, U_] := Module[{prob, state, Proj, i},*)
(*        Proj =Table[TensorProduct[I1, P[[i]], I2],{i,n}];*)
(*        prob=Table[Expand[\[CapitalPsi]\[ConjugateTranspose].Proj[[i]].\[CapitalPsi]][[1]][[1]],{i,n}]; (*Probabilities*)*)
(*        state=Table[Map[Simplify,Transpose[{Normalize[ U\[Transpose].Transpose[Proj[[i]].U.\[CapitalPsi] ][[1]]]}]],{i,n}]; (*States*)*)
(*        {prob, state}*)
(*];*)
(**)
(*(* GetPermutationMatrix: Computes the Permutation Matrix given the permutations *)*)
(*(* Inputs \[Implies] p: the permutation \[CapitalPi], n: number of elements in the permutation *)*)
(*(* e.g., for the \[CapitalPi] = (0) (1 2 4 8) (5 10) (6 12 9 3) (7 14 13 11) (15), input {0 2 4 6 8 10 12 14 1 3 5 7 9 11 13 15} *)*)
(*(* Output \[Implies] the Permutation Matrix *)*)
(*GetPermutationMatrix[p_, n_]:= Module[{permMat, i, j},*)
(*       permMat = Table[0, {i, n}, {j, n}];*)
(*       Do[permMat[[i]][[p[[i]]]]=1,{i,n}];*)
(*       permMat*)
(*];*)
(**)
(*(* GetPermutationMatrix: Computes the Permutation Matrix given the permutations *)*)
(*(* Inputs \[Implies] n: number of elements in the permutation, r: number of bits to shit *)*)
(*(* Output \[Implies] the Permutation Matrix *)*)
(*GetPermutationMatrixByLeftRotation[ n_, r_]:= Module[{permMat, i, j, f, s, max},*)
(*       max = 2^n - 1 ;*)
(*       permMat = Table[0, {i, max + 1}, {j, max + 1}];*)
(*       Do[f = BitAnd[BitShiftLeft[i, r],max]; s = BitShiftRight[i, n - r]; permMat[[i + 1]][[f+s + 1]]=1,{i, 0, max}];*)
(*       permMat*)
(*];*)
(**)
(*(* ShowEntangledOutputTables: Shows the Output Tables *)*)
(*(* Inputs \[Implies] V: Bell basis orthonormal eignevectors, P: Projectors, \[CapitalPsi]: The EPR pairs, *)
(*			prob: Probabilities, state: States, n: Dimension of the EigenSpace *)*)
(*(* Output \[Implies] None *)*)
(*ShowEntangledOutputTables[question_,\[CapitalPsi]1_,\[CapitalPsi]2_,\[CapitalPsi]_,V_,P_,prob_,state_, n_, I1_, I2_,pVerify_, col1_,col2_,col3_,col4_,col5_, si_,st_,sv_, so_, sp_] :=     Module[{inputTable,verifyTable, outputTable, projTable, permTable, permMat, i, j, k, statestring1, statestring2, statestring}, *)
(*        {statestring1,statestring2,statestring} =  Switch[question, 1,{"|EPR\!\(\*SubscriptBox[\"\[RightAngleBracket]\", \"01\"]\)", "|EPR\!\(\*SubscriptBox[\"\[RightAngleBracket]\", \"23\"]\)", "|EPR\!\(\*SubscriptBox[\"\[RightAngleBracket]\", \"01\"]\)\[CircleTimes]|EPR\!\(\*SubscriptBox[\"\[RightAngleBracket]\", \"23\"]\)"},*)
(*		 							                                                               2,{"|GHZ\!\(\*SubscriptBox[\"\[RightAngleBracket]\", \"012\"]\)", "|GHZ\!\(\*SubscriptBox[\"\[RightAngleBracket]\", \"345\"]\)", "|GHZ\!\(\*SubscriptBox[\"\[RightAngleBracket]\", \"012\"]\)\[CircleTimes]|GHZ\!\(\*SubscriptBox[\"\[RightAngleBracket]\", \"345\"]\)"}, *)
(*                                                                                                                                         3,{"|GHZ\!\(\*SubscriptBox[\"\[RightAngleBracket]\", \"012\"]\)", "|GHZ\!\(\*SubscriptBox[\"\[RightAngleBracket]\", \"345\"]\)", "|GHZ\!\(\*SubscriptBox[\"\[RightAngleBracket]\", \"012\"]\)\[CircleTimes]|GHZ\!\(\*SubscriptBox[\"\[RightAngleBracket]\", \"345\"]\)"}, *)
(*                                                                                                                                         4,{"|Werner\!\(\*SubscriptBox[\"\[RightAngleBracket]\", \"012\"]\)", "|GHZ\!\(\*SubscriptBox[\"\[RightAngleBracket]\", \"345\"]\)", "|Werner\!\(\*SubscriptBox[\"\[RightAngleBracket]\", \"01\"]\)\[CircleTimes]|GHZ\!\(\*SubscriptBox[\"\[RightAngleBracket]\", \"345\"]\)"},          *)
(*													                          5,{"|Werner\!\(\*SubscriptBox[\"\[RightAngleBracket]\", \"012\"]\)", "|EPR\!\(\*SubscriptBox[\"\[RightAngleBracket]\", \"34\"]\)", "|Werner\!\(\*SubscriptBox[\"\[RightAngleBracket]\", \"012\"]\)\[CircleTimes]|EPR\!\(\*SubscriptBox[\"\[RightAngleBracket]\", \"34\"]\)"}          *)
(*                                                                                                                ];		*)
(*         inputTable = Table[If[i == 0, Switch[j, 1, statestring1 <> ToString[Dimensions[\[CapitalPsi]1]], *)
(*                                                                         2, statestring2<> ToString[Dimensions[\[CapitalPsi]2]], *)
(*							      3, statestring<> ToString[Dimensions[\[CapitalPsi]]]],*)
(*	                                                            Switch[j, 1, MatrixForm[\[CapitalPsi]1], 2, MatrixForm[\[CapitalPsi]2],3, MatrixForm[\[CapitalPsi]]]], *)
(*			{i,0, 1},{j, 3}];      *)
(*       projTable = Table[If[i == 0, Switch[j, 1, "", 2, "Projectors"],*)
(*		                                          Switch[j, 1, i, 2, MatrixForm[TensorProduct[I1, P[[i]], I2]]]],									 *)
(*			{i,0, n},{j, 2}];         *)
(*verifyTable = Table[If[k == 1,Switch[j, 1, "\[Sum]P = I", 2, "\!\(\*SubscriptBox[\"P\", \"i\"]\).\!\(\*SubscriptBox[\"P\", \"i\"]\) = \!\(\*SubscriptBox[\"P\", \"i\"]\)", 3, "\[Sum]p = 1", 4, "\!\(\*SubscriptBox[\"P\", \"i\"]\).\!\(\*SubscriptBox[\"P\", \"j\"]\)=0, i\[NotEqual]j" ],*)
(*                                                                               Switch[j, 1, Sum[P[[i]],{i,n}]== IdentityMatrix[Dimensions[P][[2]]], *)
(*			       		                                                2, pVerify, *)
(*			       		                                                3, If[Sum[prob[[i]],{i,n}]==1, True, False],*)
(*				       	                                                4, True]],  *)
(*			{k,2},{j, 4}];*)
(*        outputTable = Table[If[i == 0, Switch[j, 1, "Bell Basis", 2, "Bell Projectors", 3, "I(x)Projector(x)I",4, "Probability", 5, "State"],*)
(*		                                                             Switch[j, 1, MatrixForm[V[[i]]\[Transpose]], *)
(*									 2, MatrixForm[P[[i]]], *)
(*									 3, MatrixForm[TensorProduct[I1, P[[i]], I2]],*)
(*									 4, prob[[i]], *)
(*									 5, MatrixForm[state[[i]]]]], *)
(*			{i,0, n},{j, 5}];*)
(*         (* Check by swapping the entangled bits by permutation matrix *)*)
(*         (* Entanglement swapping permutation: i.e., (0) (1 2 4 8) (5 10) (6 12 9 3) (7 14 13 11) (15) *)                   						 *)
(*          permMat = Switch [question, *)
(*                                       1, GetPermutationMatrixByLeftRotation[4,1], *)
(*                                       (* permMat = GetPermutationMatrix[{1,3, 5, 7, 9, 11, 13, 15, 2, 4, 6, 8, 10, 12, 14, 16 },16]; *)*)
(*                                       3, GetPermutationMatrixByLeftRotation[6,3]*)
(*                                    ];*)
(*         permTable = Switch [question,*)
(*                                                       1, Table[If[i == 0, *)
(*                                                              Switch[j, 1, "|EPR\!\(\*SubscriptBox[\"\[RightAngleBracket]\", \"01\"]\)|EPR\!\(\*SubscriptBox[\"\[RightAngleBracket]\", \"23\"]\)", *)
(*                                                                                     2, "(0) (1 2 4 8) (5 10) (6 12 9 3) (7 14 13 11) (15)",       *)
(*                                                                                     3,  "|EPR\!\(\*SubscriptBox[\"\[RightAngleBracket]\", \"12\"]\)|EPR\!\(\*SubscriptBox[\"\[RightAngleBracket]\", \"30\"]\)"], *)
(*	                                                    Switch[j, 1, MatrixForm[\[CapitalPsi]], 2, MatrixForm[permMat],3, MatrixForm[permMat.\[CapitalPsi]]]], *)
(*                                                             {i,0, 1},{j, 3}],*)
(*                                                      3, Table[If[i == 0, *)
(*                                                             Switch[j, 1, "|GHZ\!\(\*SubscriptBox[\"\[RightAngleBracket]\", \"012\"]\)\[CircleTimes]|GHZ\!\(\*SubscriptBox[\"\[RightAngleBracket]\", \"345\"]\)",*)
(*                                                                                    2, "(0 1 2 3 4 5) -> (3 4 5 0 1 2)",       *)
(*                                                                                    3,  "\!\(\*SubscriptBox[\"P\", *)
(*RowBox[{*)
(*RowBox[{\"(\", \"012345\", \")\"}], \" \", \"->\", \" \", *)
(*RowBox[{\"(\", \"345012\", \")\"}]}]]\).|GHZ\!\(\*SubscriptBox[\"\[RightAngleBracket]\", \"012\"]\)\[CircleTimes]|GHZ\!\(\*SubscriptBox[\"\[RightAngleBracket]\", \"345\"]\)"], *)
(*	                                                  Switch[j, 1, MatrixForm[\[CapitalPsi]], 2, MatrixForm[permMat],3, MatrixForm[permMat.\[CapitalPsi]]]], *)
(*   			                           {i,0, 1},{j, 3}]*)
(*                                        ]; *)
(*          (* Show Outputs *)*)
(*          Grid[inputTable,Alignment-> Center,Spacings->{si,1},Frame->All,ItemStyle->"Text",Background->{{None,None},{col1,None}}]*)
(*          Grid[projTable,Alignment-> Center,Spacings->{st,1},Frame->All,ItemStyle->"Text",Background->{{None,None},{col2,None}}]*)
(*          Grid[verifyTable,Alignment-> Center,Spacings->{sv,1},Frame->All,ItemStyle->"Text",Background->{{None,None},{col3,None}}]*)
(*          Grid[outputTable,Alignment-> Center,Spacings->{so,1},Frame->All,ItemStyle->"Text",Background->{{None,None},{col4,None}}]If [question ==1 || question ==3, Grid[permTable,Alignment-> Center,Spacings->{sp,1},Frame->All,ItemStyle->"Text",Background->{{None,None},{col5,None}}] ,]*)
(*];*)
(**)
(*(* Measure the Entangled System *)*)
(*MeasureEntangledSystemWithBellBasis[question_,si_: 12, st_: 10, sv_:10,so_:6, sp_: 6] := *)
(*Module[{pair1,pair2,pairs,I1dim,I2dim, V,P,prob, state, pVerify},*)
(*          (* Compute Pairs *)*)
(*          {pair1,pair2,pairs} =  Switch[question, 1, ComputeEPRPairs0123Entangled[], *)
(*									                    2, ComputeGHZPairs012345Entangled[], *)
(*                                                                                                          3, ComputeGHZPairs012345Entangled[], *)
(*									                    4, ComputeWernerGHZPairs012345Entangled[], *)
(*                                                                                                          5, ComputeWernerEPRPairs01234Entangled[]]; *)
(*          {I1dim, I2dim} = Switch[question, 1, {2, 2},  2, {4, 4}, 3, {4, 4},  4, {4, 4},  5, {4, 2}];	*)
(*          *)
(*         (* Compute Bell Basis *)*)
(*          V = ComputeBellBasis[]; *)
(*         (* Compute Projectors *)*)
(*         {P, pVerify} = ComputeBellProjectors[V, 4];*)
(*         *)
(*(* Compute Probabilities and States *)*)
(*        {prob, state} = If [question == 3,   (* Measure bits 0 & 5 instead : (0 1 2 3 4 5) -> (3 4 5 0 1 2) : Rotate 3 bits to left *)*)
(*                                                 ComputeBellProbStatesWithUnitaryTransform[P,pairs,4, IdentityMatrix[I1dim], IdentityMatrix[I2dim], GetPermutationMatrixByLeftRotation[ 6, 3]],*)
(*                                                 ComputeBellProbStates[P,pairs,4, IdentityMatrix[I1dim], IdentityMatrix[I2dim]] *)
(*                                  ];*)
(*       *)
(*        (* Shows Output Tables *)*)
(*         ShowEntangledOutputTables[question, pair1,pair2,pairs,V,P,prob,state,4, IdentityMatrix[I1dim],IdentityMatrix[I2dim], pVerify,*)
(*         Red, Blue,Green, Yellow,Pink,si, st, sv, so, sp]                    *)
(*];*)
(**)
(*(* Question 1 *)*)
(*MeasureEntangledSystemWithBellBasis[3] *)
(**)
(*(* Question 2 */)*)
(*MeasureEntangledSystemWithBellBasis[2] *)
(**)
(*(* Question 3 *)*)
(*MeasureEntangledSystemWithBellBasis[3] *)
(**)
(*(* Question 4 *)*)
(*MeasureEntangledSystemWithBellBasis[4] *)
(**)
(*(* Question 5 *)*)
(*MeasureEntangledSystemWithBellBasis[5] *)
(*(/**)*)
(**)
(*End[]*)
(**)
(*EndPackage[]*)


(* ::Text:: *)
(**)
