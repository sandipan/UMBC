(* ::Package:: *)

(* ::Input:: *)
(*(*---------------------------------------------------------------------------------*)*)
(*(*---------------- Sandipan Dey, UMBC CSEE ----------------------------------------*)*)
(*(*---------------- The Source Code for Quantum Package-----------------------------*)*)
(*(*---------------- Functions --------------------------------------------------------*)
(*				1. ComputeOrthonormalEigenSpaces *)
(*                2. ComputeProjectors *)
(*                3. ComputeProbStates *)
(*			    4. ShowOutputTables*)
(*				5. MeasureQuantumSystem                 *)
(*-----------------------------------------------------------------------------*)*)
(**)
(*BeginPackage["Quantum`"]*)
(**)
(*Begin["`Private`"]*)
(**)
(*(* ComputeOrthonormalEigenSpaces: Computes the Orthonormal EigenSpaces *)*)
(*(* Inputs \[Implies] \[CapitalOmega]: The Obserrvable *)*)
(*(* Output \[Implies] EigenValues, EigenVectros and the Dimensions of the EigenSpaces *)*)
(*ComputeOrthonormalEigenSpaces[\[CapitalOmega]_] := Module[{n, \[CapitalLambda], V,\[CapitalLambda]o, Vo, i},*)
(*n=Dimensions[\[CapitalOmega]][[1]];(*\[CapitalOmega] Square Matrix*)*)
(*{\[CapitalLambda],V}=Eigensystem[\[CapitalOmega]];(*Find EigenValues and Orthogonal EigenVectors*)*)
(*(*Construct Orthonormal EigenKets in the respective EigenSpaces*)*)
(*Clear[\[CapitalLambda]o]; Do[\[CapitalLambda]o[\[CapitalLambda][[i]]]= \[CapitalLambda][[i]],{i,n}];*)
(*Clear[Vo]; Do[Vo[\[CapitalLambda][[i]]]= {},{i,n}]; Do[Vo[\[CapitalLambda][[i]]]=Append[Vo[\[CapitalLambda][[i]]],V[[i]]],{i,n}]; *)
(*Do[If[Dimensions[Vo[\[CapitalLambda][[i]]]][[1]]==1,Vo[\[CapitalLambda][[i]]]= {Normalize[Vo[\[CapitalLambda][[i]]][[1]]]},Vo[\[CapitalLambda][[i]]]= Orthogonalize[Vo[ \[CapitalLambda][[i]]]]],{i,n}];*)
(*\[CapitalLambda]=DownValues[\[CapitalLambda]o][[All,2]];V=DownValues[Vo][[All,2]]; n=Dimensions[\[CapitalLambda]][[1]];(*Dimension of Eigen Space*)*)
(*{\[CapitalLambda], V, n}*)
(*];*)
(**)
(*(* ComputeProjectors: Computes the Projectors *)*)
(*(* Inputs \[Implies] V: EigenSpace buckets containing orthonormal eignevectors, n: Dimension of the EigenSpace *)*)
(*(* Output \[Implies] n Projectors *)*)
(*ComputeProjectors[V_,n_] := Module[{P, pVerify, oVerify, i, j, ZeroMatrix, ket, braw, m, p, Pr},*)
(*  pVerify = oVerify = True;*)
(*  P = Table[0, {i,  n}, {j, 1}];*)
(*  Do[{m, p} = Dimensions[V[[i]]]; P[[i]]= Table[0,{r,p},{c,p}];*)
(*          Do[ket = {V[[i]][[j]]}\[Transpose]; braw = ket\[ConjugateTranspose]; Pr = ket.braw; If [Pr.Pr !=  Pr, pVerify = False, ] ; P[[i]] = P[[i]] + Pr,{j,m}],{i,n}];*)
(*          ZeroMatrix= Table[0, {i, p}, {j,p}];Do[Do[If[P[[i]].P[[j]]!=ZeroMatrix   and i !=   j,oVerify = False,],{i,n}],{j,n}]; (*Verify Kronecker*)*)
(*  {P, pVerify}*)
(*];*)
(**)
(*(* ComputeProbStates: Computes the Probabilities and the States *)*)
(*(* Inputs \[Implies] P: n Projectors, \[CapitalPsi]: Quantum System, n: Dimension of the EigenSpace *)*)
(*(* Output \[Implies] n Probabilities and the States *)*)
(*ComputeProbStates[P_,\[CapitalPsi]_,n_] := Module[{prob, state, i},*)
(*prob=Table[Expand[\[CapitalPsi]\[ConjugateTranspose].P[[i]].\[CapitalPsi]][[1]][[1]],{i,n}]; (*Probabilities*)*)
(*state=Table[Map[Simplify,Transpose[{Normalize[ Transpose[P[[i]].\[CapitalPsi] ][[1]]]}]],{i,n}]; (*States*)*)
(*{prob, state}*)
(*];*)
(**)
(*(* ShowOutputTables: Shows the Output Tables *)*)
(*(* Inputs \[Implies] \[CapitalOmega]: The Obserrvable, \[CapitalLambda]: EigenValues, V: EigenSpace buckets containing orthonormal eignevectors, P: Projectors, \[CapitalPsi]: The Quantum System, *)
(*			prob: Probabilities, state: States, n: Dimension of the EigenSpace *)*)
(*(* Output \[Implies] None *)*)
(*ShowOutputTables[\[CapitalOmega]_,\[CapitalPsi]_,\[CapitalLambda]_,V_,P_,prob_,state_, n_, pVerify_, si_, sv_, so_] := Module[{inputTable, verifyTable, outputTable, i, j, k},*)
(*   inputTable    = Table[If[i == 1, Switch[j, 1, "Observable", 2, "QuantumSystem"],Switch[j, 1, MatrixForm[\[CapitalOmega]], 2, MatrixForm[\[CapitalPsi]]]], {i,2},{j, 2}];*)
(*   verifyTable = Table[If[k == 1,Switch[j, 1, "\[Sum]P = I", 2, "\[Sum]\[Lambda]P = \[CapitalOmega]", 3, "\!\(\*SubscriptBox[\"P\", \"i\"]\).\!\(\*SubscriptBox[\"P\", \"i\"]\) = \!\(\*SubscriptBox[\"P\", \"i\"]\)", 4, "\[Sum]p = 1", 5, "\!\(\*SubscriptBox[\"P\", \"i\"]\).\!\(\*SubscriptBox[\"P\", \"j\"]\)=0, i\[NotEqual]j" ],		                                                   *)
(*                                                            Switch[j, 1, Sum[P[[i]],{i,n}]== IdentityMatrix[Dimensions[P][[2]]], *)
(*			       		                                  2, Sum[\[CapitalLambda][[i]]*P[[i]],{i,n}] ==\[CapitalOmega], *)
(*		       			                                  3, pVerify, *)
(*			       		                                  4, If[Sum[prob[[i]],{i,n}]==1, True, False],*)
(*				       	                                  5, True]],*)
(*			{k,2},{j, 5}];*)
(*    outputTable = Table[If[i == 0, Switch[j, 1, "EigenValue", 2, "EigenSpace", 3, "Projector", 4, "Probability", 5, "State"],*)
(*		                                            Switch[j, 1, \[CapitalLambda][[i]], 2, MatrixForm[V[[i]]\[Transpose]], 3, MatrixForm[P[[i]]], 4, prob[[i]], 5, MatrixForm[state[[i]]]]], *)
(*			{i,0, n},{j, 5}];*)
(* (* Show Outputs *)*)
(*   Grid[inputTable,Alignment-> Center,Spacings->{si,1},Frame->All,ItemStyle->"Text",Background->{{None,None},{Orange,None}}]*)
(*   Grid[verifyTable,Alignment-> Center,Spacings->{sv,1},Frame->All,ItemStyle->"Text",Background->{{None,None},{None,None}}]*)
(*   Grid[outputTable,Alignment-> Center,Spacings->{so,1},Frame->All,ItemStyle->"Text",Background->{{None,None},{Green,None}}]*)
(*   ];*)
(**)
(*(* MeasureQuantumSystem: Measures the Quantum System with the Observable *)*)
(*(* Inputs \[Implies] \[CapitalOmega]: The Obserrvable, \[CapitalPsi]: The Quantum System *)*)
(*(* Output \[Implies] None *)*)
(*MeasureQuantumSystem[\[CapitalOmega]_,\[Psi]_, si_: 19, sv_: 6, so_:4] := Module[{\[CapitalLambda],V, n, P, pVerify, prob, state},*)
(*(* Compute Orthonormal EigenSpaces *)*)
(*{\[CapitalLambda],V, n}= ComputeOrthonormalEigenSpaces[\[CapitalOmega]];*)
(*(* Compute Projectors *)*)
(*{P, pVerify} = ComputeProjectors[V, n];*)
(*(* Compute Probabilities and States *)*)
(*{prob, state} = ComputeProbStates[P,\[Psi],n];*)
(*(* Shows Output Tables *)*)
(* ShowOutputTables[\[CapitalOmega],\[Psi],\[CapitalLambda],V,P,prob,state,n, pVerify, si, sv, so]*)
(*];*)
(**)
(*(* MeasureQuantumSystem: Measures the Quantum System with the Observable *)*)
(*(* Inputs \[Implies] \[CapitalOmega]: The Obserrvable, \[CapitalPsi]: The Quantum System *)*)
(*(* Output \[Implies] None *)*)
(*MeasureQuantumSystemWithBellBasis[\[CapitalOmega]_,\[Psi]_, si_: 19, sv_: 6, so_:4] := Module[{\[CapitalLambda],V, n, P, pVerify, prob, state},*)
(*(* Compute Orthonormal EigenSpaces *)*)
(*{\[CapitalLambda],V, n}= ComputeOrthonormalEigenSpaces[\[CapitalOmega]];  V = BellBasis[];  Print[MatrixForm[V]];(* n must be 4 *)*)
(*(* Compute Projectors *)*)
(*{P, pVerify} = ComputeProjectors[V, n];*)
(*(* Compute Probabilities and States *)*)
(*{prob, state} = ComputeProbStates[P,\[Psi],n];*)
(*(* Shows Output Tables *)*)
(* ShowOutputTables[\[CapitalOmega],\[Psi],\[CapitalLambda],V,P,prob,state,n, pVerify, si, sv, so]*)
(*];*)
(**)
(*(*- MeasureQuantumSystem::usage="Measure the prob / state of a quantum system";*)
(*SetAttributes[MeasureQuantumSystem,{ReadProtected,Locked}]; -*)*)
(**)
(*Basis[n_] := Module[{i, j},*)
(*		Table[If [i == j, 1, 0],{i,n},{j,n}]		*)
(*];*)
(**)
(*BellBasis[] := Module[{i, j, b, p00, p01, p10, p11, b1, b2, b3, b4},*)
(*                    b = Basis[2];*)
(*	          p00 = TensorProduct[Ket[0, b], Ket[0,b]] ;*)
(*		 p11 = TensorProduct[Ket[1, b], Ket[1,b]] ;*)
(*	          p01 = TensorProduct[Ket[0, b], Ket[1,b]] ;*)
(*		 p10 = TensorProduct[Ket[1, b], Ket[0,b]] ;*)
(*	          b1 = (p00 + p11) / Sqrt[2];*)
(*		 b2 = (p01 + p10) / Sqrt[2];*)
(*		 b3 = (p01 - p10) / Sqrt[2];*)
(*		 b4 = (p00 - p11) / Sqrt[2];*)
(*		 {b1\[Transpose], b2\[Transpose], b3\[Transpose], b4\[Transpose]}*)
(*];*)
(**)
(*Bra[k_, b_] := {b[[k + 1]]};*)
(*Ket[k_, b_] := Bra[k, b]\[ConjugateTranspose];*)
(*BraVec[coeff_, b_] := KetVec[coeff, b]\[ConjugateTranspose];*)
(*KetVec[coeff_, b_] := Module[{n, v, i},*)
(*	n = Dimensions[b][[1]];*)
(*	v = Table[0, {i, n}, {j,1}];*)
(*	Do [v = v + coeff[[i]] * Ket[i - 1, b], {i,n}];*)
(*	v*)
(*];*)
(*InnerProduct[\[CapitalPsi]1_, \[CapitalPsi]2_] := \[CapitalPsi]1\[ConjugateTranspose].\[CapitalPsi]2;*)
(*InnerProductReal[\[CapitalPsi]1_, \[CapitalPsi]2_] := \[CapitalPsi]1\[Transpose].\[CapitalPsi]2;*)
(*TensorProduct[\[CapitalPsi]1_, \[CapitalPsi]2_] := KroneckerProduct[\[CapitalPsi]1,\[CapitalPsi]2];*)
(*TensorProduct[\[CapitalPsi]1_, \[CapitalPsi]2_, \[CapitalPsi]3_] := KroneckerProduct[KroneckerProduct[\[CapitalPsi]1,\[CapitalPsi]2],\[CapitalPsi]3];*)
(**)
(*(*----------- Inputs ----------*)*)
(*(*Example 1*)*)
(*  \[CapitalOmega]={{0,0,1,-I}, {0,0,I,-1}, {1,-I,0,0},{I,-1,0,0}};(*Observable*)   \[CapitalPsi]=Transpose[{Normalize[({1,I,0,-1})]}];(*State*)*)
(* MeasureQuantumSystem[\[CapitalOmega],\[CapitalPsi]]*)
(* (*Ex 1.1*)*)
(*  \[CapitalOmega]={{2,0,0,I}, {0,2,0,0}, {0,0,2,0},{-I,0,0,2}};(*Observable*)   \[CapitalPsi]=Transpose[{Normalize[({1,1,1,1})]}];(*State*)*)
(* MeasureQuantumSystem[\[CapitalOmega],\[CapitalPsi]]*)
(*(*Ex 1.2*)*)
(* \[CapitalOmega]={{5,0,0,3I}, {0,5,I,0}, {0,-I,5,0},{-3I,0,0,5}};(*Observable*)  \[CapitalPsi]=Transpose[{Normalize[({1,1,1,1})]}];(*State*)*)
(* MeasureQuantumSystem[\[CapitalOmega],\[CapitalPsi]]*)
(* MeasureQuantumSystemWithBellBasis[\[CapitalOmega],\[CapitalPsi]]*)
(**)
(*End[]*)
(**)
(*EndPackage[]*)
